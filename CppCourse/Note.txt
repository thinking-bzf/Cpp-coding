I/O格式控制
包含<iomanip>文件
设置小数点: setprecision(int) 放在要输出数字的前面
设置域宽:setw(int)
cout<<setw(5)<< setprecision(2)<<3.245<<endl;

枚举类型:
enum Weekday {Sun,Mon,Tue,Wed,Fri,Sat}
枚举中的值都是常量，不能对其赋值，且都具有默认值从0开始一次递增。
enum Weekday day;声明枚举类型变量

函数参数传递
引用:为变量建立一个别名，相当于指针，但是没有创建新的内存

内联函数:(消除函数调用开销,提高运行速度)
内联函数不是在调用时发生发生转移，而是在编译时将函数体嵌入在每一个函数体内
内联函数即普通函数之前加上inline 其余不变。内联函数不能很复杂，会导致代码膨胀，当函数比较复杂时，编译器会将其转换成普通函数。
内联函数中不能有循环语句,内联函数的声明必须出现在函数第一次调用之前
类结构中所有在类说明体内定义的都是内联函数


重载函数:
形参类型不同，形参个数不同。
当使用默认参数值的函数重载形式需要注意二义性。
void fun(int length,int w=1,int h=1);
void fun(int length);
以上无法辨别

引用:当且仅当当引用作为函数返回值时，可以作为赋值符号的左值，可以被写操作

类的访问权限:
私有成员，保护成员:只能被本类访问，两者的区别在继承体现
公有成员:公开可以访问 

构造函数允许是内联函数
创建一个对象指针不会调用构造函数
构造函数参数列表赋值 
class time
{
    int hour;
    int minute;
    public:
    time(int h,int m):hour(h),minute(min){}
};

复制构造的形参时本类的对象引用
复制构造函数不能重载
复制构造函数调用的情况:
1.用一个类去初始化该类的另一个对象
2.如果函数的形参时类的对象，调用函数时，进行形参和实参结合(只有把对象用值传递时才会调用复制构造，如果传递引用就不会调用复制构造函数)
3.如果函数的返回值时类的对象，函数执行完成返回调用者

当创建组合类时，有内嵌的类，这个组合类调用构造函数是使用参数列表来初始化组合类中的内嵌类
调用构造函数的顺序:内嵌类->自身的构造
析构函数则与构造函数的执行顺序相反。

命名空间
具有命名空间作用域的变量也称为全局变量

静态变量
static 关键字
用该关键字之后的变量生存期与程序的生存期相同。
使用static变量的成员实现类的共享
如 static int count
初始化: int 类名::count=0;//类外

静态函数成员
在未定义任何对象时，在主函数中直接调用  类名::静态函数
静态成员函数可以直接访问该类的静态数据和函数成员，而访问非静态成员，必须通过对象名

友元:提高程序运行效率
友元函数，可以使非成员函数访问该类的私有成员和保护成员
friend 函数返回类型 函数名 函数参数列表 
在类内进行声明 在类外进行定义
友元类
在A类声明 friend class B;
B是A的友元，所以在B的成员函数中可以访问A类对象的私有成员
注意:友元是不能传递的，友元关系是单向的，友元关系是不能继承的

指向函数的指针
声明 数据类型 (*函数指针名)(参数表)

指向类非静态成员的函数指针 
声明
    类型说明符 类名::指针名           //声明指向 数据成员的指针
    类型说明符 (类名::*指针名)(参数表) //声明指向函数成员的指针
赋值
    指针名 =&类名::数据成员名         //数据成员
    指针名 =类名::函数名             //函数成员
对象指针成员引用
    对象.*类成员指针名
    或 对象指针名->*类成员指针名
对象指针成员函数引用
    (对象.*类成员指针名)(参数表)
    或 (对象指针名->*类成员指针名)(参数表)
常成员函数需要写明确const
对类的静态成员的访问不依赖于对象,可以用普通的指针来指向和访问静态成员

string类
函数：
append(s) 将字符串s添加到本串尾部
assign(s) 赋值，将s所指的字符串赋值给本对象
compare(s) 比较 本串>s为正 本串<s为负 相等为0
insert(pos,s) 将s所指向的字符串插入到本串的位置pos之前
substr(pos,n) 取本串pos开始的n个字符，构建新的string类作为返回值
find(str) 查找并返回str在本串中第一次出现的位置
length() 返回字符个数

const int *p1 指p1指针指向的是一个(const) int类型的变量 该指针指向的const int 变量不能被修改，
              但p1可以更改指向的地址，指向其他变量，此时尽管被指向的变量不是const，*p1也不能被修改。
int *const p2 指向的是int类型的变量，不能指向const int变量，该指针一旦被赋值就不能指向其他变量.当前指向的变量可以被修改。
常对于常数据成员要用初始化列表初始值,不能在定义该变量时初始化

移动构造
右值引用&& 在在运行时自动创建临时变量为右值，在运行完这块函数后释放其内存
强制移动:move(变量)

继承与派生
吸收基类成员时，派生类包含了全部基类中的除构造和析构函数之外的所有非静态成员,静态成员会伴随整个类继续存在
继承方式与访问权限
公有继承，基类的公有成员和保护成员的访问属性在派生类中不变，基类的私有呈半圆不能直接访问
私有继承：基类的所有成员都以私有成员的形式出现在派生类中,派生类中的成员都不能访问这些成员
保护继承：基类中的公有成员和保护成员都以保护成员的身份出现在派生类中，私有成员不可以直接访问
        即派生类中的其他成员可以访问公有成员和保护成员，但是类外不能被访问。

B为基类 B->C
B b1,*pb1;
D d1;
*派生类的对象可以隐含转换成基类对象     b1=d1;
*派生类的对象可以初始化基类的引用       B &rb=d1;
*派生类的指针可以隐含转换为基类的指针   pb1=&d1;
转换之后派生类可以作为基类的对象使用，但只能使用从基类继承来的成员

派生类构造函数执行的次序
*调用基类构造函数，调用顺序按照他们被继承时声明的顺序(左->右)
*对派生类新增的成员对象初始化，调用顺序按照他们在类中声明的顺序
*执行派生类构造函数体中的内容
详见base123.cpp
析构的顺序与构造的顺序相反

虚基类
当一个基类有多个副本时，同一个和函数名会有多个映射
可以将共同基类设置为虚基类，这时从不同的路径继承过来的同名数据成员在内存中只有一个副本，用一个函数名也只有一个映射
class 派生类名::virtual 继承方式 基类名
派生类继承了虚基类继承而来的基类时，需要在构造函数参数列表中添加虚基类的参数的初始化

运算符重载
重载++,--
前置++  类名& operator++()
后置++  类名 operator++(int)
前置+/-:友元函数 B operator+(int x, B &rhs)
重载[] 判断是否越界(assert函数)后return 下标指向的内容
重载* 数组类 a *a可以将指向a的指针转换成指向a中的list成员

虚函数
区分指针指向的动态对象调用的函数
虚函数的判定条件:该函数基类的虚函数名称、参数个数、参数类型是否相同。返回值相同或者返回值是否满足赋值兼容
只有通过的指针或引用调用虚函数才会发生动态绑定
应用:函数传参为基类指针或引用
基类的指针或引用可以指向派生类，但是基类的对象不能
Base1 d
Base0 b=d
以上会出现对象切片的情况，即b只有Base0的成员 失去了Base1的成员
而Base0 *b 或Base0 &b不会出现切片问题。
当构造一个派生类时，先调用基类的构造函数，如果构造函数中调用了虚函数，调用的是基类的虚函数，因为此时对象还不是派生类的对象
析构的时候同理

虚析构函数
防止用基类指针指向非基类对象的时候,不调用非基类的析构函数，导致删除不彻底而内存泄漏

纯虚函数
纯虚函数是在基类中声明的虚函数，不给出实现方法
virtual 函数类型 函数名(参数列表)=0;
如果将析构函数声明为纯虚函数，那必须给出他的实现
带有纯虚函数的类不能进行实例化
如果派生类没有给出全部纯虚函数的实现，那么这个派生类还是抽象类
抽象类不能实例化

函数模板的定义
template<class T>
template<class T1,class T2>

函数对象:函数名<需要传参的类型>
模板类实例化
类名<T的类型>
模板的实现和声明需要放在一个文件中

为了给模板特殊的功能，可以进行特化和偏特化
模板特化
template<> class Pair<int,int>{}
template<>
class Stack(bool,32){}
实现:void Stack<bool,32>::push(bool item){}

模板偏特化
template<class T1> class Pair<T1,int>{}
template<SIZE>
class stack(bool,SIZE){}
实现:void Stack<bool,SIZE>::push(bool item){}

迭代器
输入流迭代器:
istream_iterator(istream &in);

输出流迭代器:
ostream_iterator(ostream& out);
ostream_iterator(ostream& out,分隔符);

copy算法
copy(迭代器开始，迭代器结束，输出迭代器);
copy(a.begin(),s.end(),ostream_iterator<int>(cout,"\t"));
迭代器辅助函数
advance(迭代器,int n),将迭代器向前递增n个单位

容器:
基本功能s
S s
s.begin()
s.end()
s.empty() 判断是否为空
s.size()
s.swap(s1) s1和s中的内容交换
以上迭代器的声明方式 
    S::iterator ...
    S::const_iterator...
s.rbegin()  得到指向容器最后一个元素的逆向迭代器
s.rend()  得到指向容器第一元素的前一个位置的逆向迭代器
逆向迭代器的声明方式 
    S::reverse_iterator...
    S::const_reverse_iterator...
逆向输出:copy(s.rbegin(),s.rend(),ostream_iterator<int>(cout," "));

顺序容器 S 函数
构造函数
S<> s(n,t);  构造一个n个元素为t的容器
S<> s(n);    构造一个有n元素的容器
S<> s(p1,p2);将[p1,p2)区间的数据作为s的元素构造 如数组

对s赋值，与构造函数差不多
s.assign(n,t);
s.assign(n);
s.assign(p1,p2)

元素插入
s.insert(p1,t)      在p1-1和p1之间插入值为t的元素 返回插入元素
s.insert(p1,n,t)    在p1-1和p1之间插入n个元素t 没有返回值
s.insert(p1,q1,q2)  在p1-1和p2之间插入[q1,q2)区间的元素

元素删除
s.erase(p1) 删除s1容器中p1所指的元素 返回被删除的下一个元素的迭代器
s.erase(p1,p2) 删除容器[p1,p2)区间的元素 最后一个被删除的元素的下一个迭代器

改变容器的大小
s.resize(n) 多的增加，少则删除

首位元素的访问
s.front() 获取容器首元素的引用
s.back()  或取容器尾元素的引用

在容器的尾部插入删除元素
s.push_back(t) 在尾部插入元素t
s.pop_back()   删除尾部元素

在容器的首部插入或删除元素
s.push_front(t) 在首部插入元素t
s.pop_front() 删除首部元素

向量(vector)
双端队列(deque) 两边都可以插入元素
链表(list) 
list的特殊操作splice
list s1 
s1.splice(p,s2)       将s2列表的所有元素都插入到p1-1和p1之间s2裂变清空
s1.splice(p,s2,q1)    将s2列表所指向的元素插入到s1列表中的p1-1和p1之间，将q1所指向的元素从s2列表中删除
s1.splice(p,s2,q1,q2) 将s2列表中[q1,q2)的元素插入到s1列表中的p1-1和p1之间，将[q1,q2)的元素从s2中删除

容器适配器
栈stack 队列queue 不支持迭代器，因为不能对任意元素进行访问
S 为适配器
S s;
s.size()  返回元素个数
s.empty() 返回是否为空
s.push(t) 将t元素压入s中
s.pop()   将元素从s中弹出 栈弹最后压入的 队列弹最先被压入的

栈 s.top() 访问栈顶元素
队列 
s.front() 获取队头元素
s.back() 获取队尾元素

关联容器
组合类型用pair类表示(包含于<utility>)
单重关联容器set
多重关联容器multiset 可以包括相同的元素

关联容器 S s
s.insert(t) 将t插入s中 只有不存在相同键时，返回pair<S::iterator,bool>,(指单重关联容器)
如果插入成功，返回被插入元素的迭代器和true，不成功，返回已存在的元素的迭代器和false
s.find(k)   找到任意一个键为k的元素，返回该元素的迭代器，如果s中没有键为k的元素，返回s.end()
s.count(k)  得到s容器中的键为k得元素个数

函数对象
类似函数指针
bind1st()固定第一个参数
bind2en()固定第二个参数
ptr_fun() 辅助一般函数指针到适配器中适配 绑定适配器中可用
mem_fun() 辅助成员函数适配

STL算法
find_if (迭代器开始，迭代器结束，函数对象(i))(函数对象返回bool)
find_if 返回迭代器 用*可以对其解引用
find_if(vec.begin(),vec.end(),bind2nd(greater<int>(),3));
count_if(迭代器开始，迭代器结束，函数对象(i))(函数对象返回bool)
返回符合函数函数对象的个数
count_if(vec.begin(),vec.end(),bind2nd(greater<int>(),3));
函数对象常见需要二元绑定适配器

generate(迭代器，迭代器，函数对象)
generate(vec.begin(), vec.end(), random);

transform(原值起始，原值结束，存放开始，函数对象);(一元)
transform(vec.begin(), vec.end(), vec1.begin(), bind1st(ptr_fun(xmulty), 5));

transform(原值1起始，原值2结束，原值2开始，存放开始，函数对象);(二元)
transform(vec.begin(), vec.end(), vec.begin(), vec3.begin(), xmulty);
详见10-13.cpp

文件流
ofstream类支持磁盘文件输出
如果在构造函数中指定一个文件名，当构造这个文件时该文件是自动打开的
ofstream myFile("filename");
可以在调用默认构造函数之后使用open成员函数打开文件
ofstream myFile; //声明一个静态文件输出流对象
myFile.open("filename");    //打开文件，使流对象与文件建立联系
在构造对象或用open打开文件时可以指定模式
ofstream myFile("filename", ios_base::out | ios_base::binary);

设置宽度
setw(n)

#include<fstream>
fstream file("文件名",打开模式)
打开模式:
ios_base::app    打开输出文件用于文件尾部添加数据
ios_base::ate    打开现有文件(用于输入和输出)并查找到结尾
ios_base::in     打开输入文件
ios_base::out    打开文件，用于输出
ios_base::trunc  打开文件，删除其中已有的内容
ios_base::binary 以二进制打开文件
二进制输出到文件
file.write((char *)&dog1, sizileeof(dog2));
二进制文件写入
file.read((char *)&dog2, sizeof(dog2));

字符串输入流
#include<sstream>
string a;
getline(cin,a);
istringstream ss(a);
string s;
a>>s;

异常处理详见12-4.cpp
